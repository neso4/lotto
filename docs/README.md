# 기능
## 구현할 기능 목록
- [x] 로또 구입 금액을 요청한다.
	- [x] 구입금액을 입력해 달라는 메시지를 출력한다.
	- [x] 사용자가 입력한 구입금액을 받는다.
	- [x] 잘못된 입력이 발생했을 경우 예외 처리한다.
		- [x] 0원 이하인 경우 예외 처리한다.
		- [x] 1,000원 단위로 나누어 떨어지지 않는 경우 예외 처리한다. 
		- [x] 변환할 수 없는 값일 경우 예외 처리한다.
- [x] 발행한 로또 수량 및 번호를 출력한다.
	- [x] 로또 번호의 숫자 범위는 1~45까지이다.
	- [x] 로또 번호는 오름차순으로 정렬하여 보여준다.
	- [x] 중복되지 않는 6개의 숫자를 뽑는다.
- [x] 당첨 번호를 요청한다.
	- [x] 당첨 번호를 입력해 달라는 메시지를 출력한다.
	- [x] 사용자가 입력한 당첨 번호들을 받는다.
		- [x] 쉼표를 기준으로 입력받는다.
	- [x] 잘못된 입력이 발생했을 경우 예외 처리한다.
		- [x] 각각의 숫자가 1~45 범위가 아닐 경우 예외 처리한다.
		- [x] 6자리의 수가 아닌 경우 예외 처리한다.
		- [x] 변환할 수 없는 값일 경우 예외 처리한다.
- [x] 보너스 번호를 요청한다
	- [x] 보너스 번호를 입력해 달라는 메시지를 출력한다.
	- [x] 사용자가 입력한 보너스 번호를 받는다.
	- [x] 잘못된 입력이 발생했을 경우 예외 처리한다.
		- [x] 1~45 범위가 아닐 경우 예외 처리한다.
		- [x] 변환할 수 없는 값일 경우 예외 처리한다.
		- [x] 당첨 번호에 포함된 경우 예외 처리한다.
- [x] 당첨 통계를 출력한다.
	- [x] 구입한 로또 번호들과 입력한 당첨번호 및 보너스 번호를 기준으로 통계를 구한다.
	- [x] 당첨 기준과 금액에 대해 구현한다.
		- 1등: 6개 번호 일치 / 2,000,000,000원
		- 2등: 5개 번호 + 보너스 번호 일치 / 30,000,000원
		- 3등: 5개 번호 일치 / 1,500,000원
		- 4등: 4개 번호 일치 / 50,000원
		- 5등: 3개 번호 일치 / 5,000원
	- [x] 당첨 기준, 금액, 총 몇 개가 해당 기준에 속했는지를 보여준다.
	- [x] 총 수익률을 보여준다.
		- [x] 수익률은 소수점 둘째 자리에서 반올림한다.
		- [x] 총 당첨 금액 / 구입 금액 * 100
## 지켜야 할 사항
- 사용자가 잘못된 값을 입력할 경우 `IllegalArgumentException`를 발생시키고, `[ERROR]`로 시작하는 에러 메시지를 출력 후 그 부분부터 입력을 다시 받는다.
	- `Exception`이 아닌 `IllegalArgumentException`, `IllegalStateException` 등과 같은 명확한 유형을 처리한다.
- 사용자 입력 시 `camp.nextstep.edu.missionutils.Console`의 `readLine()`을 활용한다.
- 랜덤 숫자 생성 시 `camp.nextstep.edu.missionutils.Randoms`의 `pickUniqueNumbersInRange()`를 활용한다.
- depth는 2까지만 허용한다.
- 메서드가 한 가지 일만 하도록 최대한 작게 만들어라.
- 메서드의 길이가 15라인을 넘어가지 않도록 구현한다.
- else, switch/case를 사용하지 않는다.
- Enum을 적용한다.
- 도메인 로직에 단위 테스트를 구현해야 한다.
- 핵심 로직과 UI 로직을 분리해 구현한다.
- 제공된 Lotto 클래스를 활용해 구현한다.
	- numbers 접근 제어자 변경 불가.
	- 필드 추가 불가.
	- 패키지 변경 가능.
	- 추가 기능 구현.

# 시도한 사항들
## TDD
코수타를 보며, `잘하기`가 아닌 `자라기`를 목적으로 삼았습니다. 따라서 평소에는 시도하지 못 했던 TDD를 수행해보기로 하였습니다.
TDD에 대한 책을 보고 싶었으나 당장 구할 수가 없었고, 일주일이라는 짧은 시간을 효율적으로 활용하기 위해 구글링 및 유튜브를 통한 단편화된 개념을 습득했습니다.
구현할 기능 목록을 바탕으로 메서드들을 생각해 보고, 역할을 부여한 뒤 테스트 코드를 작성하기로 했는데, 생각보다 쉽지 않아 시간이 모자랐습니다.

## 역할과 책임 나누기
지난주처럼 역할과 책임을 기반으로 요구사항을 분리하고, 각각의 기능을 수행할 클래스들을 작성하였습니다.
특히 TDD와 결합되니 '이 클래스가 이러한 역할을 한다고 이해할 수 있을까?'하는 생각을 더욱 끌어낼 수 있었습니다. 클래스명과 메서드명이 없는 채로, 역할에 집중하여 네이밍부터 진행할 수 있었기 때문이라 생각합니다.

# 고민한 사항들
> 해당 사항들은 결과론적인 내용을 담고 있습니다. 프로젝트를 진행하며 순간순간의 고민을 보고 싶으신 분들은 번거로우시더라도 이전 커밋을 참조해 주세요.

## 왜 InputView, OutputView를 인터페이스로 작성하셨나요?
현재의 요구사항은 콘솔로 인한 입력, 출력만을 바라고 있으나, 이는 언제든지 변경될 수 있다고 판단했기 때문입니다.
특히 지난주 같은 경우, 출력(Output)에 `쉼표로 구분`이라는 조건이 있었습니다.
쉼표로 구분한다는 것은 입력(Input)의 범위 내에 있는 것으로, 입력 구현체가 변경되면 구분자 또한 변경될 수 있으리라 생각했습니다.
따라서 해당하는 구현체가 인터페이스를 통해 확장하며, 명확하게 동작할 수 있는 상황을 가정하여 인터페이스로 작성하였습니다.
각각의 메서드가 문자열이 아닌 자료형을 뱉는 것도 이와 같은 이유입니다.
예로, 이번 로또를 예시로 들 경우 터치스크린을 이용한 입력에서 1~45에 해당하는 숫자 반환 버튼이 콘솔 입력을 대체할 수 있습니다.
해당하는 상황에서는 문자열이 아닌 정수형의 모음을 반환해야 할 것입니다. 이처럼 각각의 메서드가 기본적인 자료형을 반환하도록 하여 명확성을 더하고자 하였습니다. 

## 왜 Enum에 모든 정보(일치하는 숫자 개수, 보너스 번호 확인 유무, 수령할 금액)를 작성하셨나요?
처음엔 일치하는 개수와 당첨금을 따로 정의하고, 보너스 확인 유무는 Map과 함수형 메서드를 통해 각 정보들을 하나로 묶으려 하였습니다.
그러나 해당하는 구조의 큰 단점들이 있었습니다.
- 확장할 때 여러 코드를 건드려야 했습니다.
	- 로또 당첨 기준과 그에 대한 금액을 추가하고자 한다면(즉 확장이 일어나야 한다면), 당첨 기준에 가서 enum을 추가하고, 당첨금에 가서 enum을 추가하고, Map에 두 enum을 연결하여야 했습니다.
	- 만약 보너스 번호에 대한 구분까지 추가되어야 한다면 추가적인 함수형 메서드도 작성해줘야 했습니다.
- 이로 인해 일치하는 개수와 당첨금을 잘못 연결하는 오용 가능성이 있었습니다.
	- Map에 연결을 시킬 때 잘못 작성한다면 원치 않는 결과가 나올 수 있었습니다. 테스트 코드에서 확인할 수야 있으나, 너무 바쁜 일정에 추가적인 테스트를 작성하지 못 한다면 이는 큰 문제로 확산될 수 있을거라 판단했습니다.
	- 역시나 보너스 번호로 인한 구분도 위와 같이 테스트코드에서 깜빡하고 확인하지 못 했다면 문제가 생겼습니다.
- 출력 결과를 위해 강제되는 코드들이 생겼습니다.
	- 금액만 출력하는 게 아닌, 당첨 기준과 금액을 모두 출력문구에 넣어줘야 했습니다. 강제로 짝을 지어 넣어줄 수는 있겠으나, 보너스 문구를 위해 DTO에 플래그를 심어야 했습니다. 만약 실수하여 플래그를 잘못 입력했을 경우 실제 조건과 동떨어진 출력문구가 나오게 되었습니다.

위와 같은 문제를 해결하기 위해 여러 구조를 생각했고 쉬운 확장을 위해서는 모든 값을 Enum에 제시하되, 이에 대한 로직(당첨 순위 구분 로직 등)을 스스로 생성할 수 있어야 한다고 생각했습니다.
또한 Enum 객체수가 급격하게 늘어나며 일어날 수 있는 실수를 방지하기 위해 '일치하는 숫자 개수'와 '보너스 번호 확인 유무'가 다른 당첨 순위와 겹친다면 런타임 시 예외를 발생하게끔 만들었으며, 일치 개수가 음수거나 1등의 개수를 넘는 등의 있을 수 없는 경우에 대해서도 예외를 발생시키도록 하였습니다.
즉, **확장으로 인한 자동화와 그에 따른 실수를 방지할 수 있게끔** 작업하려 노력하였습니다.

## 예외 클래스를 많이 작성하신 이유가 있을까요?
예외 처리를 할 때, 직접 작성한 클래스가 아닐 경우 애플리케이션이 확실하게 문제를 일으켜야 한다고 생각했습니다.
이번 요구사항에 `Exception이 아닌 명확한 유형을 처리하라`고 되어 있는 만큼, 제가 예외사항으로 둔 것들에 대해서만 잘 처리하고자 하였습니다.
만약 제가 처리한 내용이 아닌 예외가 발생하는 경우, 이는 코드가 잘못 작성된 것이며 그 순간 애플리케이션이 예외로 인해 중지되어야 현재 어떠한 문제를 놓쳤는지(지금 발생한 예외가 무엇 때문에 났으며, 이러한 사항을 어떻게 처리할 것인지) 명확히 알아차릴 수 있다고 판단했기 때문입니다.
물론 하나의 예외에 메시지만 달리 하여 처리할 수도 있었겠지만, 하나의 예외 클래스가 모든 예외 사항에 대해 처리하는 게 좋지 않은 일이라 판단했습니다.
해당하는 경우 예외 메시지를 통해 내가 바라는 예외인지 확인해야 하는데, 예외 메시지는 변동될 가능성이 높으므로 특정 예외 클래스가 맞는지를 통해 예측한 예외와 발생한 예외의 일치를 확실히 하고자 하였습니다.

# 느낀 점 및 아쉬운 점
**TDD를 통해 좋은 설계가 만들어지는 것이 아니다, 좋은 설계를 했을 때 TDD가 쉬워지는 것이다**라는 말이 있습니다.
이번에 처음으로 TDD를 하면서, 정말 이 말이 맞다는 생각이 들었습니다.
처음에 설계한 구조가 불명확했다 보니, 작업할 수록 속도가 더뎌졌습니다. 고민하는 시간이 너무나도 길어졌고, 그조차 좋은 설계라 할 수 있는지 잘 모르겠습니다.
다만 각각의 클래스들을 하나로 엮는 과정에서 자연스레 객체지향적인 구조가 만들어지기도 했습니다. 기존에 따로 설계를 했던 만큼 서로의 연계성이 적었고, 전처럼 하나의 루트를 생각하며 개발하는 게 아닌 여러 방향으로 고려하게 되어 그런 것 같습니다.
시간이 더 있었다면 더욱 많은 고민을 바탕으로 코드를 작성했을 텐데 그러지 못 해 아쉽습니다. 그럼에도 불구하고 TDD를 도전해봤으며, 그에 따른 깨달음을 얻은 것 같아 기쁩니다.
추후에는 정말 테스트 기반으로 코드를 작성하고 완성해 나아가는 경험을 해보고 싶습니다.