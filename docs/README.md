## 구현할 기능 목록
* 입출력
    * [사용자에게서 입력 받기] ✅
    * [게임 안내 메시지 출력] ✅
    * [로또 구입 결과 출력] ✅
    * [당첨 내역 출력] ✅


* 검증
    * [입력받은 로또 구입 금액 검증] ✅
        * 예외 상황
            * 숫자 이외의 문자를 입력했을 때 ✅
            * 공백을 입력했을 때 ✅
            * 아무 값도 입력하지 않았을 때 ✅
            * 음수, 소숫점, 계산식을 입력했을 때 ✅
            * 맨 앞자리가 0일 때 ✅
            * 1000 으로 나누어 떨어지지 않을 때 ✅
            * 최소 최대 범위를 벗어날 때 (현재 범위 : 최소 1,000 / 최대 100,000) ✅
            * 자료 구조에 담을 수 없는 범위의 숫자를 입력했을 때 ✅
    * [당첨 로또 번호 입력 검증] ✅
        * 예외 상황
            * 숫자 이외의 문자를 입력했을 때(개행 포함) ✅
            * 콤마 이외의 특수문자를 입력했을 때 ✅
            * 공백을 입력했을 때 ✅
            * 아무 값도 입력하지 않았을 때 ✅
            * 음수, 소숫점, 계산식을 입력했을 때 ✅
            * 숫자들의 범위가 최소, 최대 범위를 벗어날 때 (현재 범위 : 최소 1 / 최대 45) ✅
            * 중복된 숫자가 존재할 때 ✅
            * 입력값의 맨 앞 또는 맨 뒤에 콤마가 존재할 때 ✅
            * 연속된 콤마가 존재할 때 ✅
            * 정해진 개수보다 더 많거나 적은 로또 번호를 입력할 때 ✅
    * [보너스 번호 입력 검증] ✅
        * 예외 상황
            * 정해진 범위를 벗어난 숫자를 입력했을 때 ✅
            * 자연수 이외의 숫자를 입력했을 때 ✅
            * 당첨 로또 번호와 중복된 숫자가 존재할 때 ✅


* 검증 이외의 서비스 로직 기능
    * [사용자에게서 입력 받은 당첨 로또 번호 분리] ✅
    * [수익률 계산] ✅
    * [구매한 로또 번호 오름차순 정렬] ✅
    * [잘못된 입력시 입력 반복 요구] ✅


* 도메인(비즈니스) 로직 기능
    * [로또 구입] ✅
    * [발매 로또 번호 랜덤 생성] ✅
    * [구입한 로또와 당첨 로또 번호 비교] ✅
        * [보너스 번호에 따라 2등 결정] ✅ 
    * [당첨 갯수 확인] ✅

## 사용한 패턴 : MVC 패턴 + 옵저버 패턴
이번 과제에는 옵저버 패턴이 **당첨 로또 번호 객체 - 구입한 로또 번호 객체**가 **1:N의 관계**를 맺기에, 적합하다고 생각해서 사용했습니다.
사실 옵저버 패턴 없이도 구현할 수 있지만, 패턴을 한번 더 연습할 겸 해서 사용했습니다.
옵저버 패턴 사용 시 장점 :
* **적어도 가장 중요한 도메인 객체인 두 로또 객체끼리는 확실하게 의존하지 않는다** 
* **구입한 로또 번호 객체 스스로가 다른 객체에 대한 의존 없이 값을 비교해서 등수를 매길 수 있다.**



## 특이사항

* 검증 클래스
  * `Validator` 인터페이스를 구현하는 3가지의 검증 클래스가 있습니다.
  * 이 검증 클래스들은 각각 구매 금액 입력, 당첨 로또 번호 입력, 보너스 번호 입력을 검증합니다.
  * `LottoSettingService` 클래스의 검증하고자 하는 메서드를 실행하면 `getValidInput()` 메서드가 호출되고,
    `validateInput()` 메서드에서 `ErrorMessageSender` 클래스의 `validateAndGetErrorMessage()` 를 호출하여
 검증 시 에러가 발생한다면 에러 메시지를 가져옵니다. 이 에러 메시지를 `Consumer` 함수형 인터페이스를 통해 출력시키고,
  올바른 값을 입력받을 때까지 `Supplier` 함수형 인터페이스를 통해 입력을 받습니다.
* 상속
  * PurchasedLotto , WinningLotto 클래스가 Lotto 클래스를 상속합니다. 상속은 부모와 자식 객체간에 강하게 결합한다는 단점이 있지만,
  확실한 IS-A 관계이고 이후 변경점이 거의 없을 것으로 예상되어서 코드의 재사용성을 높이기 위해 상속을 사용했습니다.
* 컨테이너(?) 클래스
  * 컨트롤러에서 너무 많은 생성자 주입을 방지하기 위해 서비스 클래스들의 객체를 담은 컨테이너 클래스 `LottoServices`, 검증 클래스들의 객체를 담은 `LottoValidators` 클래스를 작성했습니다.
  컨트롤러 내부에서 관련 객체를 호출하려면 .을 한번 더 사용해야 한다는 단점이 있지만, 수많은 생성자를 주입할 때와 달리 전체적인 코드는 훨씬 깔끔해졌습니다.
* 정적 팩토리 메서드
  * `Application` 에서 생성자 주입을 용이하게 하기 위해 생성자 주입된 컨트롤러 객체를 반환하는 `LottoFactory` 클래스를 작성했습니다.
* 등수의 Enum 클래스 관리
  * `LottoRank` 열거형 클래스를 만들어 등수와 상금을 관리하게 했습니다. 이로서 구매된 로또 객체들은 스스로 등수를 상태로 가지기 용이하게 되었고, 
  `ProfitRateCalculator` 클래스의 수익률 계산 시에도 간편하게 값을 계산할 수 있게 되었습니다.
* `BigDecimal` 클래스 사용
  * `float`, `double` 자료형은 소수점을 정밀하게 계산하지 못하기에, 소수점을 정밀하게 계산할 수 있는
  `BigDecimal` 클래스를 수익률을 계산하는 `ProfitRateCalculator` 클래스에서 사용했습니다.