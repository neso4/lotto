### 다이어 그램
<img src="https://github.com/OiKimiO/java-lotto-6/assets/53805469/23fbc637-b184-4390-9852-04a85ab00c5f" style="width:70%;" />

### 패키지 구조
<table>
    <thead>
        <tr>
            <th>Package</th>
            <th>SubPackage</th>
            <th>Class</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan="6">config</td>
            <td rowspan="2">exception</td>
            <td>ExceptionType</td>
            <td>에러 메시지들의 내용을 관리합니다.</td>
        </tr>
        <tr>
            <td>InputException</td>
            <td>입력 예외를 처리합니다.</td>
        </tr>
        <tr>
            <td rowspan="2">output</td>
            <td>MessageType</td>
            <td>모든 출력 메시지들의 내용을 관리합니다.</td>
        </tr>
        <tr>
            <td>OutputMessage</td>
            <td>출력 메시지들을 처리합니다.</td>
        </tr>
        <tr>
            <td rowspan="2">X</td>
            <td>AppConfig</td>
            <td>전반적인 실행에 있어 필수 의존성을 관리합니다.
                <br/>
                (<b>MVC는 싱글턴, 일부 필수 클래스(*)는 생성자로 관리</b>)
            </td>
        </tr>
        <tr>
            <td>LottoProcess</td>
            <td>로또 실행 절차를 가지고 있습니다.
                <br />
                (<b>AppConfig 생성자로 관리*</b>)
            </td>
        </tr>
        <tr>
            <td>controller</td>
            <td>X</td>
            <td>LottoController</td>
            <td>View의 요청을 받아 Domain, Model에게 행동을 지시합니다.</td>
        </tr>
        <tr>
            <td rowspan="9">domain</td>
            <td rowspan="2">constant</td>
            <td>LottoConstant</td>
            <td>도메인 중 상수로 처리되는 클래스의 모음입니다.</td>
        </tr>
        <tr>
            <td>PrizeAmount</td>
            <td>당첨 수익금을 관리합니다.
                <br />
                (<b>AppConfig 생성자로 관리*</b>)    
            </td>
        </tr>
        <tr>
            <td>util</td>
            <td>RandomNumber</td>
            <td>외부 랜덤 숫자를 관리합니다.</td>
        </tr>
        <tr>
            <td rowspan="6">X</td>
            <td>Lotto</td>
            <td>로또 당첨 번호를 관리합니다.</td>
        </tr>
        <tr>
            <td>LottoSet</td>
            <td>로또 당첨번호, 보너스 번호를 관리합니다.</td>
        </tr>
        <tr>
            <td>Returns</td>
            <td>로또 수익률을 관리합니다.</td>
        </tr>
        <tr>
            <td>Ticket</td>
            <td>로또 복권을 관리합니다.</td>
        </tr>
        <tr>
            <td>Tickets</td>
            <td>로또 복권들을 관리합니다.</td>
        </tr>
        <tr>
            <td>WinRecord</td>
            <td>당첨 내역을 관리합니다.</td>
        </tr>
        <tr>
            <td>model</td>
            <td>X</td>
            <td>LottoModel</td>
            <td>Domain 객체를 저장하거나 조회하는 역할을 합니다.</td>
        </tr>
        <tr>
            <td rowspan="4">view</td>
            <td rowspan="2">convert</td>
            <td>ConvertToInt</td>
            <td>String을 Int로 바꾸는 역할을 합니다.</td>
        </tr>
        <tr>
            <td>ConvertToList</td>
            <td>String을 List로 변환하는 역할을 합니다.</td>
        </tr>
        <tr>
            <td rowspan="2">X</td>
            <td>LottoBuyer</td>
            <td>로또 구매자의 입력 인터페이스를 관리합니다.</td>
        </tr>
        <tr>
            <td>LottoDrawer</td>
            <td>로또 추첨자의 입력 인터페이스를 관리합니다.</td>
        </tr>
    </tbody>
</table>

### 기능 구현 목록
1. 로또를 발행한다. 
```text
로또 번호의 숫자 범위: 1 ~ 45
로또 발행: 중복되지 않는 6개의 숫자 뽑기
```

2. 로또 당첨 번호를 뽑고, 담청 등수를 확인한다.
```text
로또 번호의 숫자 범위: 1 ~ 45
당첨 번호 뽑기: 중복되지 않은 숫자 6개 + 보너스 번호 1개
당첨 등수: 1~5등
  - 1등: 6개 번호 일치 / 2,000,000,000원
  - 2등: 5개 번호 + 보너스 번호 일치 / 30,000,000원
  - 3등: 5개 번호 일치 / 1,500,000원
  - 4등: 4개 번호 일치 / 50,000원
  - 5등: 3개 번호 일치 / 5,000원
```

3. 구입한 금액 만큼 로또를 발행한다.
```text
로또 1장 가격: 1,000원
```

4. 로또 구매자의 담청 내역과 수익률을 출력한다.
```text
사용자가 구매한 로또 번호와 추첨번호를 비교
```

5. 로또 티켓을 발행한다.
```text
로또 구매 횟수: 로또 구매 금액 / 1,000
 - 나누어 떨어지지 않는 경우 예외 처리
로또 티켓: 로또 구매 횟수만큼 발행
```

6. 담청 번호를 입력 받는다.
```text
로또 담청 번호: 번호를 쉼표(,) 기준으로 구분
보너스 번호: 7
```

7. 출력시 로또 번호는 오름차순으로 정렬해 보여준다.
```text
출력 예시:
3개를 구매했습니다.
[8, 21, 23, 41, 42, 43] 
[3, 5, 11, 16, 32, 38] 
[7, 11, 16, 35, 36, 44] 
``` 

8. 담청 내역을 출력한다.
```text
출력 예시:
3개 일치 (5,000원) - 1개
4개 일치 (50,000원) - 0개
5개 일치 (1,500,000원) - 0개
5개 일치, 보너스 볼 일치 (30,000,000원) - 0개
6개 일치 (2,000,000,000원) - 0개
```

9. 수익률은 소수점 둘째 자리에서 반올림한다.
```text
출력 예시: 총 수익률은 62.5%입니다.
```

10. 예외 상황시 에러 문구를 출력, 단 에러 문구는 `[ERROR]`로 시작해야 한다.
```text
출력 예시: [ERROR] 로또 번호는 1부터 45 사이의 숫자여야 합니다.
```

### 3차 과제 적용 
1. **MVC 패턴 적용**

    이번 3차 과제에선 MVC 패턴을 적용해보았습니다.

    MVC 패턴을 적용한 이유는 **의존성 관리**, **명확한 역할 분담**을 위해서였습니다.
   
    <br />
   
    MVC패턴의 역할은 다음과 같습니다. 

    <br />    

    **View**  

    View는 입력을 관리하는 역할입니다. 

    입력에 있어, **데이터를 변환**(Convert), **오류 발생시 재입력**의 책임을 가지고 있습니다. 

    <br />    

    **Controller**
    
    View에서 호출한 인터페이스(행동)를 Domain, Model에 지시한 후 응답하는 역할을 담당합니다.

    Controller에선 최대한 다른 로직을 사용하지 않고 **인터페이스 전달**을 목적으로 했습니다.

    <br />    

    **Domain**
    
    비즈니스 로직을 수행하는 역할을 담당합니다. 
    
    Domain은 **업무 로직**, 해당 **domain의 유효성 검사**를 진행하는 것을 목적으로 합니다.        

    <br />
   
    그리고 작업을 진행하며 각 객체간엔 정말 최소한의 의존성을 가지려고 노력을 많이 했습니다. 

    하지만 여전히 get()을 사용해 결합도가 높아지는 부분은 어쩔 수가 없었습니다. 

    혹시 MVC 패턴을 사용하신 분들이 있으시다면 높은 결합도를 어떻게 해결하셨나요?

    <br />    

    **Model**
    
    비즈니스 객체를 저장하고 조회하는 역할을 담당합니다. 

    처음엔 추가하지 않으려고도 했고, 데이터의 전송을 관리하는 DTO를 사용할까도 고민했습니다.
    
    하지만 기존 Model의 역할이 **비즈니스 로직 데이터를 관리**한다는 측면에서 Model을 선택하게 되었습니다.
   
    Model을 사용하면서 Domain간에 강하게 **결합되던 의존성을 약화**시킬 수 있어서 좋았던 것 같습니다.
    
<br />

2. **필수 의존성 관리 클래스**

   필수 의존성을 관리하기 위한 AppConfig를 추가했습니다. 
   
   싱글턴의 경우 실행에 있어 **단순 데이터 입력, 전달, 전송 인터페이스**만 있는 **View, Controller, Model**을 선택했습니다. 

   또한, 필수 생성자의 경우 프로젝트를 실행함에 있어 반드시 필요한 경우 추가했습니다.

<br />

3. **도메인 최소 단위로**

   **원시값 포장**

      사실 진행하고 싶던 방법은 **원시값 포장**에 대한 것이었습니다. 
   
      **원시값 포장**을 하게 되면 스스로가 자신을 관리하기에 **책임이 명확**해집니다. 
   
      또한, 객체의 책임에 해당하는 **다양한 자료형을 넣을 수** 있게 되어 새로운 자료 구조를 추가하더라도
   
      기존의 객체를 지울 필요가 없어집니다. 

      <br />

      이와 같은 이유로 원시값을 추가하려 했으나.. 처음 적용하는 거다 보니 잘못된 부분도 있다 생각합니다. 
   
      코드를 보시면서 가능하시다면 원시값을 잘 지켜지고 있는지..! 확인 부탁드리겠습니다 ㅎ 

<br />

4. **메서드명은 15자 이하**

   이번 프리 코스를 진행하며 지켜야했던 사항입니다..
   
   최대한 지켜서 만들긴 했지만 만들면서 어딘가 모르게 부자연 스러운 부분도 있는 것 같습니다. 
   
   확인하시고 가능하시다면 답글로 남겨주세요 ..^^

<br />

5. **Custom Exception 관리**

   Exception 처리를 하나의 클래스에서 관리하도록 만들었습니다. 

   아무래도 특정 Exception을 의존하게 되면 추후 Deprecated 될 때 해당 Exception을 의존하던 코드는 

   전부 변경되어야 함으로 Custom Exception 처리가 좋은 방법이란 생각을 하게 되었습니다.  

<br />

6. **디미터 법칙 적용**

   디미터의 법칙은 요약하면 **모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는** 법칙입니다. 

   그래서 이번에는 메서드를 통해 꼬리에 꼬리를 무는 방식을 적용하지 않고 필요한 역할을 하는 도메인에서

   필요한 메서드를 가져오는 방식으로 구현해보았습니다.
   
<br />

7. **랜덤 숫자 클래스 분리**
   
   랜덤 숫자를 만드는 기능은 외부에 의해 만들어집니다. 

   추후 변경될 여지를 생각한다면 하나의 클래스로 분리해 관리를 할 수 있도록 만드는게 좋아 보여 적용하게 되었습니다. 