# 📌 요구사항 분석

> ## [ 입력 ]
> ### 구입 금액 입력
> - [x] 구입 금액은 1000원 단위로 입력한다.
> - [x] 구입 금액은 1000원 이상이어야 한다.
> - [x] 구입 금액은 숫자로만 입력한다.
> - [x] 구입 금액은 1000원으로 나누어 떨어져야 한다.
> - [x] 에러가 발생하면 에러 메시지를 출력하고 다시 입력받는다.
>
> ### 로또 번호 입력
> - [x] 로또 번호의 숫자는 1~45까지이다.
> - [x] 로또 번호는 6개를 입력한다.
> - [x] 로또 번호는 쉼표를 기준으로 구분한다.
> - [x] 반드시 숫자를 입력해야 한다.
> 
> ### 보너스 번호 입력
> - [x] 보너스 번호를 하나 입력받는다.
> - [x] 보너스 번호는 로또 번호와 중복되지 않아야 한다.
> - [x] 에러가 발생하면 에러 메시지를 출력하고 다시 입력받는다.
> - [x] 반드시 숫자를 입력해야 한다.

> ## [ 게임 로직 ]
> ### 로또 발행
> - [x] 구입 금액에 해당하는 만큼 로또를 발행한다.
> - [x] 로또 1장의 가격은 1000원이다.
> - [x] 로또 번호는 1~45까지의 숫자 중 6개를 랜덤으로 뽑는다.
> - [x] 로또 번호는 중복되지 않는다.
> 
> ### 당첨 번호 비교
> - [x] 당첨 기준에 따라 당첨 번호를 비교한다.
> - [x] 5개 일치 시 보너스 번호를 비교한다.

> ## [ 출력 ]
> ### 로또 번호 출력
> - [x] 발행한 로또 수량 및 번호를 출력한다.
> - [x] 로또 번호는 오름차순으로 정렬하여 보여준다.
> - [x] 로또 번호는 쉼표를 기준으로 구분한다.
> - [x] 로또 번호 앞 뒤에는 대괄호를 붙인다.
> - [x] 마지막에 수익률을 출력한다.
> - [x] 수익률은 소수점 둘째 자리에서 반올림한다.

---

# 📌 예외 상황
- [x] 구입 금액이 숫자가 아닌 경우
- [x] 구입 금액이 1000원으로 나누어 떨어지지 않는 경우
- [x] 입력 번호가 숫자가 아닌 경우
- [x] 입력 번호가 범위를 벗어난 경우
- [x] 입력 번호가 중복되는 경우
- [x] 입력 번호가 6개가 아닌 경우
- [x] 보너스 번호가 숫자가 아닌 경우
- [x] 보너스 번호가 범위를 벗어난 경우
- [x] 보너스 번호가 로또 번호와 중복되는 경우

---

# 📌 클래스 다이어그램
![img.png](img/Class_Diagram.png)

# 📌 피드백 체크리스트
- [x] <u>변수 이름에 자료형을 사용하지 않는다.</u>
  - 변수명이 길어지더라도 직관적이고 자료형을 사용하지 않는 방향으로 코드를 작성했습니다.
- [x] <u>한 함수가 한 가지 기능만 담당하게 한다.</u>
  - 한 메서드의 구현부가 15줄을 넘지않도록 기준을 세우고 해당 기준을 준수하며 코드를 작성했습니다.
- [x] <u>값을 하드 코딩하지 않는다.</u>
  - 상수를 모두 ENUM으로 분리하여 사용하였습니다.
- [x] <u>구현 순서도 컨밴션이다.</u>
  - 클래스에 코드 작성순서를 "상수 -> 멤버 변수 -> 생성자 -> 메서드" 순으로 작성하였습니다.

# 구현 과정에서의 고민
> ### 1️⃣ Static 키워드에 대한 고민
> 지난 주차까지는 많은 메서드에 `static` 키워드를 사용하여 전역적으로 메서드를 간단하게 사용할 수 있었고 코드에 간결성을 더할 수 있었습니다.
> 하지만 `static` 키워드를 사용하면서 생긴 문제점이 있었습니다. 
> 정적 메서드를 사용하기 위해서 많은 변수들이 정적 변수가 되어야 했고 게임 로직에서 한 번씩만 사용되는 메서드나 변수들도 정적으로 선언되어 메모리가 낭비되는 것이었습니다.
> 
> 이를 해결하기 위해 이번 주차에서는 static 키워드를 최대한 적게 사용해 보았습니다. 
> 다양한 클래스에서 공통으로 사용하는 `Parser`클래스의 메서드들만을 static으로 만들었습니다. 
> 또한, 만약 입력이 잘못되어 지속적인 입력이 들어오면 Validator에서 입력을 계속 검증해주어야 합니다. 
> 
> 여기서 세 가지 선택지가 있었습니다. 
> 첫 번째는 Validator를 static으로 구현하지 않고 도메인 생성때마다 새로 인스턴스를 생성하는 것입니다.
> 두 번째는 Validator를 static으로 구현하고 도메인 로직에서는 단순하게 호출만 하는 것입니다.
> 마지막 세 번째는 Validator를 static으로 구현하지 않고 생성자를 통해 인스턴스를 주입받는 것입니다.
> 이 세 가지 옵션 중에서 저는 세 번째 방법을 선택했습니다.
> 첫 번째 방법은 입력 오류마다 새로 인스턴스를 생성하기 때문에 성능상 좋지 않다고 생각했고, 
> 두 번째 방법은 static 메서드를 사용하기 때문에 애플리케이션이 종료될 때까지 클래스가 메모리에 올라가 있어 메모리 낭비가 발생할 것이라고 생각했기 때문입니다.
> 또한 테스트코드 작성 시 static 메서드는 mocking이 어렵다는 단점도 고려했습니다.

> ### 2️⃣ Mock 테스트
> 단위 테스트 경험이 많이 없어서 처음에는 기능별로 테스트를 진행했습니다.
> 하지만 테스트를 진행하다보니 한 가지 기능 또는 상황에 대해 테스트를 진행하면서도 여러 가지 메서드가 정상적으로 동작해야 한다는 가정이 필요했습니다.
> 만약 A라는 테스트 안에서 B라는 메서드가 실패하면 A를 테스트하기도 전에 B를 먼저 테스트해야 하는 상황이 발생하여 단위 테스트의 독립성을 지키지 못하였습니다.
> 
> 이러한 문제점을 해결하기 위해 Mock 객체를 사용했습니다. A라는 테스트 안에서 B라는 메서드는 Mocking을 함으로써 A와 독립적인 상태를 유지하도록 설정했습니다.
> 이를 통해 테스트를 진행하면서도 다른 메서드의 동작에 영향을 받지 않고 테스트를 진행할 수 있었습니다.