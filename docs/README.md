# 개발 문서

## 구현 목록

- 구매로또 지불 처리
    - 구입 금액 입력안내메시지 출력
    - 구입 금액을 숫자로 입력받는 기능
- 구매로또 생성 처리
    - 구매 장 수에 따라 생성
    - 구매한 장 수 확인메시지 출력
    - 생성된 로또 장 별로 출력
- 정답번호 생성 처리
    - 정답번호 입력 안내 메시지 출력
    - 정답번호 6자리 입력
    - 보너스번호 입력 안내 메시지 출력
    - 보너스번호 1자리 입력
- 정답번호 추첨 처리
    - 정답번호와 추측번호를 맞추어 결과를 누적
    - 누적된 결과를 토대로 각 등수 별 당첨 갯수를 연산
    - 누적된 결과를 토대로 각 당첨액수를 합산
    - 구입금액 대비 당첨금액을 비교하여 수익률 계산
    - 위 연산 결과들을 포맷에 맞게 당첨통계 안내메시지 출력

(종료)

### 구현 기능 목록

### 예외 처리 목록

- [x] 입력값이 형식을 벗어나는 경우(입력받는 값은 전부 숫자임을 참고)
- [x] 입력한 가격이 1000원 단위가 아닌 경우
- [x] 입력한 가격이 1000 ~ 100000원을 벗어나는 경우
- [x] 입력된 추측번호가 6개가 아닌 경우
- [x] 정답/추측번호의 범위가 1~45를 벗어나는 경우
- [x] 추측번호가 중복되는 경우
- [x] 정답번호 + 보너스숫자가 중복되는 경우

## 참고할 점

### 참고 용어/개념 설명

- 장 : 로또 한 줄(6개의 번호)를 부르는 단위
- 정답번호 : 당첨 기준이 되는 로또 번호 6자리와 보너스 번호 1자리짜리 로또
- 추측번호 : 정답 로또 번호를 맞추기 위해 사용자가 구매한 로또 번호 6자리짜리 로또
- 구매로또 : 말 그대로 구매한 로또들. 1개 이상으로 이루어진 추측번호의 목록을 가지고 있음.

### enums 컨벤션 소개

메시지를 표현하기 위해서 enum 클래스를 사용하고 있다. 아래는 enum을 사용하는 컨벤션 내용이다.

- 특정 클래스의 메시지 클래스는 (클래스명)Message라는 이름을 가지고 있다.
- 특정 클래스의 메시지 클래스는 동일 레벨의 enums 패키지 안에 있다.
- 특정 클래스에서 메시지 enum을 사용할 때는 static import로 생략할 수 있다. 특정 클래스가 아닌 곳에서 타 메시지 enum을 사용할 때는 생략할 수 없다.
- 앱 전역에서 사용되는 GlobalMessage는 예외다. 최상위의 enums 패키지에 위치하며, 어떤 클래스 안에서 사용하든지 static import를 이용한 enum명 생략을 사용할 수 없다.
- GlobalMessage는 io 패키지에서 참고해서는 안된다.
- enum 필드는 반드시 private final로 사용한다. get()이라는 getter를 활용해 메시지를 획득한다.
- enum 클래스를 테스트 할 때에는 get()은 테스트하지 않는다. enum 클래스는 편의 기능 공개 메서드가 있는 경우에만 테스트 한다.

### 체크리스트

- [x] 브랜치 분리 확인
- [x] 메서드 길이 최대 15라인
- [x] 둘째 자리 반올림 처리 잘 되는지 확실히 확인
- [x] Enum 사용할 것
- [x] Console, Randoms 라이브러리만 사용
- [x] 도메인 로직 단위테스트 추가
- [x] 주어진 Lotto 클래스의 numbers 필드를 변경할 수 없다. 새로운 필드 추가도 불가능하다. 패키지 변경은 가능하다. 추가 기능 구현은 가능하다.
- [ ] 구현 완료 후 기본 요구사항 3가지 충족여부 반드시 확인
- [x] 제출 전 테스트 수행 결과 확인

### 모래주머니

- 도메인 로직 단위테스트 가능한 모든 시나리오 추가하기
- 필수 요구사항에 없는 더 복잡한 도메인 기능 떠올리기(적용할 수 있는 것은 적용)
- 기능 구현과 테스트 작성의 텀 최소한으로 하기
- 의존성 주입 적극 활용 및 실행코드와 연관관계 분리 해결책 낼 것
- 하나의 개념이라도 분리할 수 있는 이유를 떠올려보고, 분리할 이유가 있다면 분리해보기

## 고민 & 생각 메모

### 2023-11-04

- 클래스 분리를 극한까지 해보자. 모래주머니 차고 극한까지 리팩토링 해볼 것.
    - 기존에는 '나눠지는게 좋겠다고 생각한 부분'이어도 '지금 필요할까?'를 고려해서 나누지 않고는 했는데, 이번에는 나눠야겠다고 생각이 드는 부분들은 극한까지 나눠보기로 한다.
- 이전에 '공통기능'이라고 생각하며 분리하여 개발했던 클래스를 그대로 재사용할 수 있는지 확인.
    - 만약 정말 범용적으로 개발한 기능들이 아니었다면, 재사용 할 수 없을 것임. 재사용이 가능할 정도로 경우의 수를 생각해서 리팩토링 할 것.
- 예외 처리가 평소와 다르다. 앱 종료가 아닌 재시도. 어떻게 할 것인가?

### 2023-11-07

- LottoGameView의 메서드를 대폭 갈아치우면서 테스트 코드의 강력함을 느꼈다.
    - 일일히 실행해서 입력값을 넣으며 테스트 할 필요가 없으니까 정말 빠르고, 그리고 입력값 중에서 예외적인 사항까지 하나하나 고려할 필요없이 오히려 내가 직접 하는 것보다도 더 정확하게(물론 테스트도 내가
      짠거지만, 어쨌든 코드는 자신이 수행되는 것을 까먹지않으니까...) 검증한다는 생각에 굉장히 심신이 편안하다. 좋다. 테스트 코드의 묘미를 조금 알게된 것 같다.
    - 테스트 작성 시기에 대해서도 조금 생각이 생겼다. TDD까지는 아직도 잘 모르겠다. 하지만 리팩토링 보다는 무조건 이전이어야 한다. 딱 나눠떨어지지는 않지만, 과정을 나눠보자면 최소한 이런 순서여야
      한다. "기능 개발 -> 테스트 코드 -> 리팩토링"
- 지저분한 중복 예외처리 로직을 개선할 수 있을 거라고 생각했고 실제로 되었다.
    - 나는 어떤 부분에서 가능할 거라고 느꼈던 걸까? 판단이라고 하기에는 떠오르는 근거가 없었음에도 지나치게 확신했던 것 같다. 왜 될 거라고 생각했을까? 어떤 부분이 나에게 가능하다는 뉘앙스를 주었을까?
      찾아두면, 다음에는 빠르게 판단을 할 수 있는... 좋은 힌트를 하나 더 갖게 될 것 같다.
- 여기저기 흩뿌려진 enums 클래스... 개념별로 나눠진건 맞다고 생각하는데.. 이게 최선일까?
    - 패키지 정리로 일단 어느정도 치웠다.

### 2023-11-08

- 의존성을 밖에서 넣어주려고(주입하려고) 하다보니까, 밖에서 넣어줄 수 없는 곳(예:인터페이스)에서는 직접 연관관계를 엮을 수밖에 없다.
    - 지난 주차부터 계속 고민해본 결과, '연관관계'만 따로 추출해서 가지고 있을 '연관관계 클래스'가 필요하다고 느꼈다. 하지만... 그렇게 되면 어플리케이션 내에서 '연관관계 클래스'와의 연관관계만큼은 끊을
      수 없게 되는 건데... 그건 괜찮은 걸까? '연관관계 클래스'가 가지고 있는 '연관관계'는 어떻게보면 메타정보인 거니까... 설정 파일이라고 생각하면 또 괜찮은 것 같기도... 설정은 앱과는 개념적으로
      완전히 분리되어 있는 거니깐... 어렵다 어려워.
- 모든 리터럴 상수는 분리되어야 하는가?
    - 그렇다고 생각했었다.
    - 그런데 내가 짠 코드를 봐도 그렇지 않은 곳이 있었다(까먹고 빼먹은거 말고).
        - 특정한 의미를 표현하기 위한 0(예: 인덱스의 시작, 무언가 값이 없다(size == 0), 나누어 떨어지지 않는다 등등..).
- 메시지를 표현하는 리터럴 문자열들은 모두 enum으로 따로 다루도록 하고 있었다. 객체별로 담당하는 enum 클래스를 둬서 그곳에 몰아넣고 있었다.
    - 그런데 객체별로 나누는 것까진 좋은데, 용도별로 나누면 더 좋을
      것 같다.
    - 그러면 해당 enum의 필드와 클래스 상수들을 가지고 더 유용한 행위를 제공할 수 있을 것 같다.
    - 예를 들어서 로또예외enum이 있으면, 로또예외처리에 필요한 숫자 범위, 자릿수 등등을 클래스 상수로, 예외를 일으켰을때 보여줄 메시지 등을 조합해서 예외 검사 행위를 제공할 수도 있다.
- DTO도 행위를 가질 수 있다고 판단했다. 그런데 단순히 값을 반환하는게 아니라 계산하는 행위까지 들어가게 되면, 그걸 계속 DTO라고 불러도 되는걸까? 그렇다고 하더라도 값의 표현을 위한 객체면 DTO라고 부를
  수 있는걸까?