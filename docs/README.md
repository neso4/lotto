# 로또
---

## 구현 전 고려해야할 사항
* 최대한 스프링 프레임워크 구조와 비슷하게 만들자 (+MVC)
* git flow을 사용하자(fork 레포는 이슈를 사용못하는거같지만 브런치 네이밍을 최대한 활용)
* TDD 방식의 테스트 코드를 작성해보자
* 유저 입력 다시 받기 예외처리 구분
* else 사용하지 않기
* Enum 사용
* 인터페이스 구현
* DI 예시 구현해 보기
---

## 구현 예상 순서
* 지난 번 처럼 스타트 클레스 - 컨트롤러 - 모델 - 서비스 - 뷰로 페키지를 나누어 개발하기로 계획
* Enum클레스를 사용하라는뜻은 모든 상수를 분류해서 Enum으로 선언하는게 맞다고 판단하여 계발 단계중 상수가 필요할때마다 그렇게 만들어보려함
* 주어진 코드에서 하나의 모델이 해당하는 `Lotto` 클레스가 이미 있음으로 모델을 제작할때는 각각의 `Lottlo` 클레스를 묶는 클레스를 만들어보려함
* 순서와 gitflow 브런치를 나눌때 페키지별로 나누는게 좋지않다 판단하여 기능 위주로 순서 변경

### 스타트 클레스 생성
스프링의 경우 `SpringApplication.run()` 으로 main함수가 시작 하기에 이를 사용해보려 한다. 

### 유저 가격입력
* 첫 입력 문자 `view` 구현
* 가격을 입력받는 기능 `controller` 구현
* 예외처리
  * 입력이 없을때
  * 숫자가 아닐때
  * 1000으로 나누어 떨어지지않을때
* 예외처리 문출력 `view` 구현
* 문자 상수로 생각되는것들 Enum으로 구현

### 가격에 랜덤 번호생성
* `domain` 에 기존 `Lotto`클레스를 가지고있는 클래스 생성
* 생성자로 유저입력 가격이 들어가면 랜덤번호 자동생성
* `service` 에서 입력받은것 `domain`생성자로 넘기며 생성하고 필요한 값만 response dto로 다시 `controller`전달 후 `view`에서 출력

### 당첨 번호입력
* 첫 입력 문자 `view` 구현
* 숫자를 받는 입력 `controoler` 구현
* 예외처리
  * 입력이 없을때
  * 1~45가 아닐때
  * `,`로 나누어진 수가 6개가 아닐때
  * 중복이 있을때
* 예외처리 문출력 `view` 구현
* 문자 상수로 생각되는것들 Enum으로 구현

### 보너스 번호 입력 
* 첫 입력 문자 `view` 구현
* 숫자를 받는 입력 `controoler` 구현
* 예외처리
  * 입력이 없을때
  * 1~45가 아닐때
  * 당첨번호화 중복이 있을때
* 예외처리 문출력 `view` 구현
* 문자 상수로 생각되는것들 Enum으로 구현

### 당첨 통계
* 당첨 통게 `view` 출력 구현
* `service` 예서  `domain`객체와 값비교해서 연산
* 문자 상수로 생각되는것들 Enum으로 구현
  

### 예외처리
* `IllegalArgumentException`, `IllegalStateException`, `NullPointerException` 적용하여 테스트처리

### DI 적용해보기
* 생성자와 인터페이스를 활용해서 생성자에 들어가는 매개변수 클레스만 변경해도 원하는 작동방식 적용가능하도록 제작
---
## 후기

처음 계획을 짤때 페키지 구분으로 계획을 하니 클레스 분류는 편하지만 그 목록 순서데로 제작을 할수가 없기에 `userFlow`에 맞춰 순서데로 제작 순서를 변경했습니다. 이게 맞춰 `gitflow`도 기능 이름으로 브런치를 파서 제작 하니 commit 메시지가 좀더 이해하기 쉽게 작성할 수 있었습니다.

이번에는 `ENUM`을 사용해야하서 이를 이용해 상수들을 `ENUM` 클레스에 묶어서 사용하였습니다.
덕분에 새로운 대답스타일을 만들거나, 새로 출력할 문자가 생기거나 했을때 수정하기 좋았습니다.

이번에 테스트 코드를 작성하며 `IllegalArgumentException`, `NullPointerException`등 사용자가 잘못 입력 하겠구나 하는 부분은 사용도 많이 해보고 익숙했지만 `IllegalStateException`를 사용하는게 쉽지 않았습니다.

이는 내가만든 코드와 사용자 간의 관계가 아닌 나와 협업하는 개발자간의 체크 포인트라고 깨닳았습니다.

어떠한 `setter` 함수가 일정 순서로 실행되어야 올바를때 나는 그 순서를 알지만 다른 누군가가 나의 `class`를 사용할때는 모를 수 있습니다. 이럴때 예외처리를통해 명확한 이유와 함께 런타임 에러 원인을 나타내줄 수 있다고 생각합니다.

마지막으로 `ENUM`과 인터페이스, 생성자 주입 구조를 통해 필요한 의존관계를 넣으며 클레스를 생성하면 내가 원하는 버전의 클레스를 사용할 수 있도록 제작하였습니다. 여러가지 버전의 `class`를 한줄의 코드 변경으로 편하게 사용할 수 있는것이 너무 혁신적인거같습니다.